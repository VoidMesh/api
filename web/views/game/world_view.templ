package game

import (
	"fmt"
	chunkV1 "github.com/VoidMesh/platform/api/proto/chunk/v1"
	worldV1 "github.com/VoidMesh/platform/api/proto/world/v1"
	"github.com/VoidMesh/platform/web/views/layouts"
	"github.com/gofiber/fiber/v2"
)

templ WorldView(c *fiber.Ctx, character *worldV1.Character, chunks []*chunkV1.ChunkData) {
	@layouts.Main(c) {
		<div class="container mx-auto p-4">
			<!-- Character Info -->
			<div class="bg-white border border-gray-200 rounded-lg p-4 mb-4">
				<div class="flex justify-between items-center">
					<div>
						<h1 class="text-2xl font-bold">{ character.Name }</h1>
						<p class="text-gray-600 character-position">Position: ({ fmt.Sprintf("%d", character.X) }, { fmt.Sprintf("%d", character.Y) })</p>
						<p class="text-gray-600">Chunk: ({ fmt.Sprintf("%d", character.ChunkX) }, { fmt.Sprintf("%d", character.ChunkY) })</p>
					</div>
					<a href="/game/characters" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">
						Back to Characters
					</a>
				</div>
			</div>
			<!-- World Map -->
			<div class="bg-white border border-gray-200 rounded-lg p-4">
				<h2 class="text-lg font-semibold mb-3">World Map</h2>
				<div class="text-center mb-4">
					<p class="text-sm text-gray-600">Showing { fmt.Sprintf("%d", len(chunks)) } chunks around your character</p>
				</div>
				<!-- Legend -->
				<div class="mb-4 grid grid-cols-2 md:grid-cols-5 gap-2 text-sm">
					<div class="flex items-center">
						<div class="w-4 h-4 bg-green-400 border mr-2"></div>
						<span>Grass</span>
					</div>
					<div class="flex items-center">
						<div class="w-4 h-4 bg-blue-400 border mr-2"></div>
						<span>Water</span>
					</div>
					<div class="flex items-center">
						<div class="w-4 h-4 bg-gray-500 border mr-2"></div>
						<span>Stone</span>
					</div>
					<div class="flex items-center">
						<div class="w-4 h-4 bg-yellow-400 border mr-2"></div>
						<span>Sand</span>
					</div>
					<div class="flex items-center">
						<div class="w-4 h-4 bg-amber-600 border mr-2"></div>
						<span>Dirt</span>
					</div>
				</div>
				<!-- World Map Grid -->
				<div class="overflow-auto max-w-full border border-gray-300 bg-gray-50">
					<div id="world-map" class="inline-block"></div>
				</div>
				<div class="text-center mt-4">
					<p class="text-sm text-gray-500 mb-2">Character at ({ fmt.Sprintf("%d", character.X) }, { fmt.Sprintf("%d", character.Y) })</p>
					<div class="text-xs text-gray-400">
						<p>Red square = Your character</p>
						<p>Each square = 1 cell in the world</p>
					</div>
				</div>
			</div>
			<!-- Movement Controls -->
			<div class="bg-white border border-gray-200 rounded-lg p-4 mb-4">
				<h2 class="text-lg font-semibold mb-3">Movement Controls</h2>
				<div class="grid grid-cols-3 gap-2 w-fit mx-auto">
					<div></div>
					<button data-direction="up" class="move-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">
						↑ Up
					</button>
					<div></div>
					<button data-direction="left" class="move-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">
						← Left
					</button>
					<div class="flex items-center justify-center bg-gray-100 rounded">
						<span class="text-sm font-medium">{ character.Name }</span>
					</div>
					<button data-direction="right" class="move-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">
						Right →
					</button>
					<div></div>
					<button data-direction="down" class="move-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">
						↓ Down
					</button>
					<div></div>
				</div>
				<p class="text-sm text-gray-600 text-center mt-3">Use WASD keys or click the buttons to move</p>
			</div>
		</div>
		@gameScript(character, chunks)
	}
}

script gameScript(character *worldV1.Character, chunks []*chunkV1.ChunkData) {
	const characterId = character.id;
	let currentX = character.x;
	let currentY = character.y;
	const initialChunkX = character.chunk_x;
	const initialChunkY = character.chunk_y;
	const worldChunks = chunks;

	// Client-side rate limiting
	let lastMoveTime = 0;
	const CLIENT_MOVE_COOLDOWN = 40; // Slightly less than server cooldown (50ms)

	function showMovementError(message) {
		// Remove any existing error messages
		const existingError = document.querySelector('.movement-error');
		if (existingError) {
			existingError.remove();
		}

		// Create error message element
		const errorDiv = document.createElement('div');
		errorDiv.className = 'movement-error fixed top-4 right-4 bg-red-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-opacity duration-300';
		errorDiv.textContent = message;

		// Add to page
		document.body.appendChild(errorDiv);

		// Auto-remove after 2 seconds
		setTimeout(() => {
			errorDiv.style.opacity = '0';
			setTimeout(() => {
				if (errorDiv.parentNode) {
					errorDiv.parentNode.removeChild(errorDiv);
				}
			}, 300);
		}, 2000);
	}

	function disableMovementButtons() {
		const buttons = document.querySelectorAll('.move-btn');
		buttons.forEach(btn => {
			btn.disabled = true;
			btn.classList.add('opacity-50', 'cursor-not-allowed');
		});
	}

	function enableMovementButtons() {
		const buttons = document.querySelectorAll('.move-btn');
		buttons.forEach(btn => {
			btn.disabled = false;
			btn.classList.remove('opacity-50', 'cursor-not-allowed');
		});
	}

	function moveCharacter(direction) {
		// Client-side rate limiting
		const now = Date.now();
		if (now - lastMoveTime < CLIENT_MOVE_COOLDOWN) {
			showMovementError('Moving too fast!');
			return;
		}
		lastMoveTime = now;

		// Disable movement buttons temporarily
		disableMovementButtons();

		fetch(`/game/world/${characterId}/move`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/x-www-form-urlencoded',
			},
			body: `direction=${direction}`
		})
		.then(response => response.json())
		.then(data => {
			if (data.success) {
				currentX = data.character.x;
				currentY = data.character.y;
				updateCharacterPosition();
				// If character moved to a new chunk, reload the page to get new chunk data
				if (data.character.chunk_x !== initialChunkX ||
					data.character.chunk_y !== initialChunkY) {
					location.reload();
				}
			} else {
				showMovementError(data.error);
			}
			// Re-enable movement buttons
			enableMovementButtons();
		})
		.catch(error => {
			console.error('Error:', error);
			showMovementError('Connection error');
			// Re-enable movement buttons
			enableMovementButtons();
		});
	}

	function updateCharacterPosition() {
		// Update position display
		const positionElements = document.querySelectorAll('.character-position');
		positionElements.forEach(el => {
			el.textContent = `Position: (${currentX}, ${currentY})`;
		});
		// Re-render map to show character in new position
		renderWorldMap();
	}

	// Button click handlers
	document.addEventListener('DOMContentLoaded', function() {
		const moveButtons = document.querySelectorAll('.move-btn');
		moveButtons.forEach(button => {
			button.addEventListener('click', function() {
				const direction = this.getAttribute('data-direction');
				moveCharacter(direction);
			});
		});
	});

	// Keyboard controls
	document.addEventListener('keydown', function(event) {
		switch(event.key.toLowerCase()) {
			case 'w':
			case 'arrowup':
				event.preventDefault();
				moveCharacter('up');
				break;
			case 's':
			case 'arrowdown':
				event.preventDefault();
				moveCharacter('down');
				break;
			case 'a':
			case 'arrowleft':
				event.preventDefault();
				moveCharacter('left');
				break;
			case 'd':
			case 'arrowright':
				event.preventDefault();
				moveCharacter('right');
				break;
		}
	});

	// Render world map using JavaScript
	function renderWorldMap() {
		const worldMapContainer = document.getElementById('world-map');
		if (!worldMapContainer) return;

		// Debug: Log chunk data
		console.log('Rendering world map with chunks:', worldChunks);
		console.log('Number of chunks:', worldChunks ? worldChunks.length : 'undefined');

		// Clear existing content
		worldMapContainer.innerHTML = '';

		// Find the bounds of the chunks
		let minChunkX = Infinity, maxChunkX = -Infinity;
		let minChunkY = Infinity, maxChunkY = -Infinity;

		worldChunks.forEach(chunk => {
			const chunkX = chunk.chunk_x || 0;
			const chunkY = chunk.chunk_y || 0;
			minChunkX = Math.min(minChunkX, chunkX);
			maxChunkX = Math.max(maxChunkX, chunkX);
			minChunkY = Math.min(minChunkY, chunkY);
			maxChunkY = Math.max(maxChunkY, chunkY);
		});

		// Calculate grid dimensions based on actual chunk range
		const gridWidth = (maxChunkX - minChunkX + 1) * 32;  // Width in cells
		const gridHeight = (maxChunkY - minChunkY + 1) * 32; // Height in cells

		// Create 2D array to hold cell data
		const gridData = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(null));

		// Debug: Log bounds and grid calculations
		console.log('Chunk bounds - minX:', minChunkX, 'maxX:', maxChunkX, 'minY:', minChunkY, 'maxY:', maxChunkY);
		console.log('Grid dimensions - width:', gridWidth, 'height:', gridHeight);

		// Fill the 2D array with chunk data
		worldChunks.forEach((chunk, chunkIndex) => {
			const chunkX = chunk.chunk_x || 0;
			const chunkY = chunk.chunk_y || 0;
			console.log(`Processing chunk ${chunkIndex}:`, chunk);
			console.log(`Chunk position: (${chunkX}, ${chunkY}), cells: ${chunk.cells ? chunk.cells.length : 'undefined'}`);

			if (chunk.cells) {
				chunk.cells.forEach((cell, cellIndex) => {
				const localX = cellIndex % 32;
				const localY = Math.floor(cellIndex / 32);

				// Calculate position relative to the chunk bounds
				const gridX = (chunkX - minChunkX) * 32 + localX;
				const gridY = (chunkY - minChunkY) * 32 + localY;

				// Place cells within the grid
				if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
					gridData[gridY][gridX] = {
						cell: cell,
						worldX: chunkX * 32 + localX,
						worldY: chunkY * 32 + localY
					};
				}
				});
			}
		});

		// Create grid container
		const grid = document.createElement('div');
		grid.style.display = 'grid';
		grid.style.gridTemplateColumns = `repeat(${gridWidth}, 8px)`;
		grid.style.gridTemplateRows = `repeat(${gridHeight}, 8px)`;
		grid.style.gap = '0';

		// Render the 2D array row by row
		for (let y = 0; y < gridHeight; y++) {
			for (let x = 0; x < gridWidth; x++) {
				const cellDiv = document.createElement('div');
				cellDiv.style.width = '8px';
				cellDiv.style.height = '8px';
				cellDiv.className = '';

				let bgColor = '#f0f0f0'; // Empty space color
				let worldX = 0, worldY = 0;

				if (gridData[y][x]) {
					const data = gridData[y][x];
					const cell = data.cell;
					worldX = data.worldX;
					worldY = data.worldY;

					// Set color based on terrain type
					switch(cell.terrain_type) {
						case 1: bgColor = '#86efac'; break; // GRASS
						case 2: bgColor = '#60a5fa'; break; // WATER
						case 3: bgColor = '#6b7280'; break; // STONE
						case 4: bgColor = '#facc15'; break; // SAND
						case 5: bgColor = '#d97706'; break; // DIRT
						default: bgColor = '#f3f4f6'; break;
					}

					// Highlight character position
					if (worldX === currentX && worldY === currentY) {
						bgColor = '#ef4444'; // Red for character
					}

					cellDiv.dataset.worldX = worldX;
					cellDiv.dataset.worldY = worldY;
					cellDiv.title = `(${worldX},${worldY}) ${getTerrainName(cell.terrain_type)}`;
				} else {
					cellDiv.title = `Empty (${x},${y})`;
				}

				cellDiv.style.backgroundColor = bgColor;
				grid.appendChild(cellDiv);
			}
		}

		worldMapContainer.appendChild(grid);
	}

	function getTerrainName(terrainType) {
		switch(terrainType) {
			case 1: return 'Grass';
			case 2: return 'Water';
			case 3: return 'Stone';
			case 4: return 'Sand';
			case 5: return 'Dirt';
			default: return 'Unknown';
		}
	}

	// Initial render when page loads
	document.addEventListener('DOMContentLoaded', renderWorldMap);
}
