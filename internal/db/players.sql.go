// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: players.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addToPlayerInventory = `-- name: AddToPlayerInventory :exec
INSERT INTO player_inventories (player_id, resource_type, resource_subtype, quantity)
VALUES (?, ?, ?, ?)
ON CONFLICT(player_id, resource_type, resource_subtype) DO UPDATE SET
    quantity = quantity + excluded.quantity,
    last_updated = CURRENT_TIMESTAMP
`

type AddToPlayerInventoryParams struct {
	PlayerID        int64         `json:"player_id"`
	ResourceType    int64         `json:"resource_type"`
	ResourceSubtype sql.NullInt64 `json:"resource_subtype"`
	Quantity        sql.NullInt64 `json:"quantity"`
}

func (q *Queries) AddToPlayerInventory(ctx context.Context, arg AddToPlayerInventoryParams) error {
	_, err := q.exec(ctx, q.addToPlayerInventoryStmt, addToPlayerInventory,
		arg.PlayerID,
		arg.ResourceType,
		arg.ResourceSubtype,
		arg.Quantity,
	)
	return err
}

const clearPlayerInventory = `-- name: ClearPlayerInventory :exec
DELETE FROM player_inventories
WHERE player_id = ?
`

func (q *Queries) ClearPlayerInventory(ctx context.Context, playerID int64) error {
	_, err := q.exec(ctx, q.clearPlayerInventoryStmt, clearPlayerInventory, playerID)
	return err
}

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (username, password_hash, salt, email)
VALUES (?, ?, ?, ?)
RETURNING player_id, username, password_hash, salt, email, world_x, world_y, world_z, current_chunk_x, current_chunk_z, is_online, last_login, last_logout, created_at, updated_at
`

type CreatePlayerParams struct {
	Username     string         `json:"username"`
	PasswordHash string         `json:"password_hash"`
	Salt         string         `json:"salt"`
	Email        sql.NullString `json:"email"`
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.queryRow(ctx, q.createPlayerStmt, createPlayer,
		arg.Username,
		arg.PasswordHash,
		arg.Salt,
		arg.Email,
	)
	var i Player
	err := row.Scan(
		&i.PlayerID,
		&i.Username,
		&i.PasswordHash,
		&i.Salt,
		&i.Email,
		&i.WorldX,
		&i.WorldY,
		&i.WorldZ,
		&i.CurrentChunkX,
		&i.CurrentChunkZ,
		&i.IsOnline,
		&i.LastLogin,
		&i.LastLogout,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlayerSession = `-- name: CreatePlayerSession :one
INSERT INTO player_sessions (player_id, session_token, ip_address, user_agent, expires_at)
VALUES (?, ?, ?, ?, ?)
RETURNING session_id, player_id, session_token, ip_address, user_agent, created_at, expires_at, last_activity
`

type CreatePlayerSessionParams struct {
	PlayerID     int64          `json:"player_id"`
	SessionToken string         `json:"session_token"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	ExpiresAt    time.Time      `json:"expires_at"`
}

func (q *Queries) CreatePlayerSession(ctx context.Context, arg CreatePlayerSessionParams) (PlayerSession, error) {
	row := q.queryRow(ctx, q.createPlayerSessionStmt, createPlayerSession,
		arg.PlayerID,
		arg.SessionToken,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
	)
	var i PlayerSession
	err := row.Scan(
		&i.SessionID,
		&i.PlayerID,
		&i.SessionToken,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastActivity,
	)
	return i, err
}

const createPlayerStats = `-- name: CreatePlayerStats :one
INSERT INTO player_stats (player_id)
VALUES (?)
RETURNING stat_id, player_id, total_resources_harvested, total_harvest_sessions, iron_ore_harvested, gold_ore_harvested, wood_harvested, stone_harvested, unique_nodes_discovered, total_nodes_harvested, total_playtime_minutes, sessions_count, first_harvest, last_harvest, stats_updated
`

func (q *Queries) CreatePlayerStats(ctx context.Context, playerID int64) (PlayerStat, error) {
	row := q.queryRow(ctx, q.createPlayerStatsStmt, createPlayerStats, playerID)
	var i PlayerStat
	err := row.Scan(
		&i.StatID,
		&i.PlayerID,
		&i.TotalResourcesHarvested,
		&i.TotalHarvestSessions,
		&i.IronOreHarvested,
		&i.GoldOreHarvested,
		&i.WoodHarvested,
		&i.StoneHarvested,
		&i.UniqueNodesDiscovered,
		&i.TotalNodesHarvested,
		&i.TotalPlaytimeMinutes,
		&i.SessionsCount,
		&i.FirstHarvest,
		&i.LastHarvest,
		&i.StatsUpdated,
	)
	return i, err
}

const deleteAllPlayerSessions = `-- name: DeleteAllPlayerSessions :exec
DELETE FROM player_sessions
WHERE player_id = ?
`

func (q *Queries) DeleteAllPlayerSessions(ctx context.Context, playerID int64) error {
	_, err := q.exec(ctx, q.deleteAllPlayerSessionsStmt, deleteAllPlayerSessions, playerID)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM player_sessions
WHERE expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteExpiredSessionsStmt, deleteExpiredSessions)
	return err
}

const deletePlayer = `-- name: DeletePlayer :exec
DELETE FROM players
WHERE player_id = ?
`

func (q *Queries) DeletePlayer(ctx context.Context, playerID int64) error {
	_, err := q.exec(ctx, q.deletePlayerStmt, deletePlayer, playerID)
	return err
}

const deletePlayerSession = `-- name: DeletePlayerSession :exec
DELETE FROM player_sessions
WHERE session_token = ?
`

func (q *Queries) DeletePlayerSession(ctx context.Context, sessionToken string) error {
	_, err := q.exec(ctx, q.deletePlayerSessionStmt, deletePlayerSession, sessionToken)
	return err
}

const getOnlinePlayers = `-- name: GetOnlinePlayers :many
SELECT player_id, username, password_hash, salt, email, world_x, world_y, world_z, current_chunk_x, current_chunk_z, is_online, last_login, last_logout, created_at, updated_at FROM players
WHERE is_online = 1
`

func (q *Queries) GetOnlinePlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.query(ctx, q.getOnlinePlayersStmt, getOnlinePlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.PlayerID,
			&i.Username,
			&i.PasswordHash,
			&i.Salt,
			&i.Email,
			&i.WorldX,
			&i.WorldY,
			&i.WorldZ,
			&i.CurrentChunkX,
			&i.CurrentChunkZ,
			&i.IsOnline,
			&i.LastLogin,
			&i.LastLogout,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerActiveSessions = `-- name: GetPlayerActiveSessions :many
SELECT session_id, player_id, session_token, ip_address, user_agent, created_at, expires_at, last_activity FROM player_sessions
WHERE player_id = ? AND expires_at > CURRENT_TIMESTAMP
ORDER BY last_activity DESC
`

func (q *Queries) GetPlayerActiveSessions(ctx context.Context, playerID int64) ([]PlayerSession, error) {
	rows, err := q.query(ctx, q.getPlayerActiveSessionsStmt, getPlayerActiveSessions, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PlayerSession{}
	for rows.Next() {
		var i PlayerSession
		if err := rows.Scan(
			&i.SessionID,
			&i.PlayerID,
			&i.SessionToken,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerByEmail = `-- name: GetPlayerByEmail :one
SELECT player_id, username, password_hash, salt, email, world_x, world_y, world_z, current_chunk_x, current_chunk_z, is_online, last_login, last_logout, created_at, updated_at FROM players
WHERE email = ? LIMIT 1
`

func (q *Queries) GetPlayerByEmail(ctx context.Context, email sql.NullString) (Player, error) {
	row := q.queryRow(ctx, q.getPlayerByEmailStmt, getPlayerByEmail, email)
	var i Player
	err := row.Scan(
		&i.PlayerID,
		&i.Username,
		&i.PasswordHash,
		&i.Salt,
		&i.Email,
		&i.WorldX,
		&i.WorldY,
		&i.WorldZ,
		&i.CurrentChunkX,
		&i.CurrentChunkZ,
		&i.IsOnline,
		&i.LastLogin,
		&i.LastLogout,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByID = `-- name: GetPlayerByID :one
SELECT player_id, username, password_hash, salt, email, world_x, world_y, world_z, current_chunk_x, current_chunk_z, is_online, last_login, last_logout, created_at, updated_at FROM players
WHERE player_id = ? LIMIT 1
`

func (q *Queries) GetPlayerByID(ctx context.Context, playerID int64) (Player, error) {
	row := q.queryRow(ctx, q.getPlayerByIDStmt, getPlayerByID, playerID)
	var i Player
	err := row.Scan(
		&i.PlayerID,
		&i.Username,
		&i.PasswordHash,
		&i.Salt,
		&i.Email,
		&i.WorldX,
		&i.WorldY,
		&i.WorldZ,
		&i.CurrentChunkX,
		&i.CurrentChunkZ,
		&i.IsOnline,
		&i.LastLogin,
		&i.LastLogout,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByUsername = `-- name: GetPlayerByUsername :one
SELECT player_id, username, password_hash, salt, email, world_x, world_y, world_z, current_chunk_x, current_chunk_z, is_online, last_login, last_logout, created_at, updated_at FROM players
WHERE username = ? LIMIT 1
`

func (q *Queries) GetPlayerByUsername(ctx context.Context, username string) (Player, error) {
	row := q.queryRow(ctx, q.getPlayerByUsernameStmt, getPlayerByUsername, username)
	var i Player
	err := row.Scan(
		&i.PlayerID,
		&i.Username,
		&i.PasswordHash,
		&i.Salt,
		&i.Email,
		&i.WorldX,
		&i.WorldY,
		&i.WorldZ,
		&i.CurrentChunkX,
		&i.CurrentChunkZ,
		&i.IsOnline,
		&i.LastLogin,
		&i.LastLogout,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerInventory = `-- name: GetPlayerInventory :many
SELECT inventory_id, player_id, resource_type, resource_subtype, quantity, first_obtained, last_updated FROM player_inventories
WHERE player_id = ?
ORDER BY resource_type, resource_subtype
`

func (q *Queries) GetPlayerInventory(ctx context.Context, playerID int64) ([]PlayerInventory, error) {
	rows, err := q.query(ctx, q.getPlayerInventoryStmt, getPlayerInventory, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PlayerInventory{}
	for rows.Next() {
		var i PlayerInventory
		if err := rows.Scan(
			&i.InventoryID,
			&i.PlayerID,
			&i.ResourceType,
			&i.ResourceSubtype,
			&i.Quantity,
			&i.FirstObtained,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerInventoryResource = `-- name: GetPlayerInventoryResource :one
SELECT inventory_id, player_id, resource_type, resource_subtype, quantity, first_obtained, last_updated FROM player_inventories
WHERE player_id = ? AND resource_type = ? AND resource_subtype = ?
LIMIT 1
`

type GetPlayerInventoryResourceParams struct {
	PlayerID        int64         `json:"player_id"`
	ResourceType    int64         `json:"resource_type"`
	ResourceSubtype sql.NullInt64 `json:"resource_subtype"`
}

func (q *Queries) GetPlayerInventoryResource(ctx context.Context, arg GetPlayerInventoryResourceParams) (PlayerInventory, error) {
	row := q.queryRow(ctx, q.getPlayerInventoryResourceStmt, getPlayerInventoryResource, arg.PlayerID, arg.ResourceType, arg.ResourceSubtype)
	var i PlayerInventory
	err := row.Scan(
		&i.InventoryID,
		&i.PlayerID,
		&i.ResourceType,
		&i.ResourceSubtype,
		&i.Quantity,
		&i.FirstObtained,
		&i.LastUpdated,
	)
	return i, err
}

const getPlayerSession = `-- name: GetPlayerSession :one
SELECT session_id, player_id, session_token, ip_address, user_agent, created_at, expires_at, last_activity FROM player_sessions
WHERE session_token = ? AND expires_at > CURRENT_TIMESTAMP
LIMIT 1
`

func (q *Queries) GetPlayerSession(ctx context.Context, sessionToken string) (PlayerSession, error) {
	row := q.queryRow(ctx, q.getPlayerSessionStmt, getPlayerSession, sessionToken)
	var i PlayerSession
	err := row.Scan(
		&i.SessionID,
		&i.PlayerID,
		&i.SessionToken,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastActivity,
	)
	return i, err
}

const getPlayerStats = `-- name: GetPlayerStats :one
SELECT stat_id, player_id, total_resources_harvested, total_harvest_sessions, iron_ore_harvested, gold_ore_harvested, wood_harvested, stone_harvested, unique_nodes_discovered, total_nodes_harvested, total_playtime_minutes, sessions_count, first_harvest, last_harvest, stats_updated FROM player_stats
WHERE player_id = ? LIMIT 1
`

func (q *Queries) GetPlayerStats(ctx context.Context, playerID int64) (PlayerStat, error) {
	row := q.queryRow(ctx, q.getPlayerStatsStmt, getPlayerStats, playerID)
	var i PlayerStat
	err := row.Scan(
		&i.StatID,
		&i.PlayerID,
		&i.TotalResourcesHarvested,
		&i.TotalHarvestSessions,
		&i.IronOreHarvested,
		&i.GoldOreHarvested,
		&i.WoodHarvested,
		&i.StoneHarvested,
		&i.UniqueNodesDiscovered,
		&i.TotalNodesHarvested,
		&i.TotalPlaytimeMinutes,
		&i.SessionsCount,
		&i.FirstHarvest,
		&i.LastHarvest,
		&i.StatsUpdated,
	)
	return i, err
}

const getPlayersInChunk = `-- name: GetPlayersInChunk :many
SELECT player_id, username, password_hash, salt, email, world_x, world_y, world_z, current_chunk_x, current_chunk_z, is_online, last_login, last_logout, created_at, updated_at FROM players
WHERE current_chunk_x = ? AND current_chunk_z = ? AND is_online = 1
`

type GetPlayersInChunkParams struct {
	CurrentChunkX sql.NullInt64 `json:"current_chunk_x"`
	CurrentChunkZ sql.NullInt64 `json:"current_chunk_z"`
}

func (q *Queries) GetPlayersInChunk(ctx context.Context, arg GetPlayersInChunkParams) ([]Player, error) {
	rows, err := q.query(ctx, q.getPlayersInChunkStmt, getPlayersInChunk, arg.CurrentChunkX, arg.CurrentChunkZ)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.PlayerID,
			&i.Username,
			&i.PasswordHash,
			&i.Salt,
			&i.Email,
			&i.WorldX,
			&i.WorldY,
			&i.WorldZ,
			&i.CurrentChunkX,
			&i.CurrentChunkZ,
			&i.IsOnline,
			&i.LastLogin,
			&i.LastLogout,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersWithStats = `-- name: GetPlayersWithStats :many
SELECT p.player_id, p.username, p.password_hash, p.salt, p.email, p.world_x, p.world_y, p.world_z, p.current_chunk_x, p.current_chunk_z, p.is_online, p.last_login, p.last_logout, p.created_at, p.updated_at, 
       COALESCE(ps.total_resources_harvested, 0) as total_resources_harvested,
       COALESCE(ps.total_harvest_sessions, 0) as total_harvest_sessions,
       COALESCE(ps.sessions_count, 0) as sessions_count,
       COALESCE(ps.total_playtime_minutes, 0) as total_playtime_minutes
FROM players p
LEFT JOIN player_stats ps ON p.player_id = ps.player_id
ORDER BY p.created_at DESC
`

type GetPlayersWithStatsRow struct {
	PlayerID                int64           `json:"player_id"`
	Username                string          `json:"username"`
	PasswordHash            string          `json:"password_hash"`
	Salt                    string          `json:"salt"`
	Email                   sql.NullString  `json:"email"`
	WorldX                  sql.NullFloat64 `json:"world_x"`
	WorldY                  sql.NullFloat64 `json:"world_y"`
	WorldZ                  sql.NullFloat64 `json:"world_z"`
	CurrentChunkX           sql.NullInt64   `json:"current_chunk_x"`
	CurrentChunkZ           sql.NullInt64   `json:"current_chunk_z"`
	IsOnline                sql.NullInt64   `json:"is_online"`
	LastLogin               sql.NullTime    `json:"last_login"`
	LastLogout              sql.NullTime    `json:"last_logout"`
	CreatedAt               sql.NullTime    `json:"created_at"`
	UpdatedAt               sql.NullTime    `json:"updated_at"`
	TotalResourcesHarvested int64           `json:"total_resources_harvested"`
	TotalHarvestSessions    int64           `json:"total_harvest_sessions"`
	SessionsCount           int64           `json:"sessions_count"`
	TotalPlaytimeMinutes    int64           `json:"total_playtime_minutes"`
}

func (q *Queries) GetPlayersWithStats(ctx context.Context) ([]GetPlayersWithStatsRow, error) {
	rows, err := q.query(ctx, q.getPlayersWithStatsStmt, getPlayersWithStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlayersWithStatsRow{}
	for rows.Next() {
		var i GetPlayersWithStatsRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Username,
			&i.PasswordHash,
			&i.Salt,
			&i.Email,
			&i.WorldX,
			&i.WorldY,
			&i.WorldZ,
			&i.CurrentChunkX,
			&i.CurrentChunkZ,
			&i.IsOnline,
			&i.LastLogin,
			&i.LastLogout,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalResourcesHarvested,
			&i.TotalHarvestSessions,
			&i.SessionsCount,
			&i.TotalPlaytimeMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPlayersByPlaytime = `-- name: GetTopPlayersByPlaytime :many
SELECT p.username, ps.total_playtime_minutes
FROM players p
JOIN player_stats ps ON p.player_id = ps.player_id
ORDER BY ps.total_playtime_minutes DESC
LIMIT ?
`

type GetTopPlayersByPlaytimeRow struct {
	Username             string        `json:"username"`
	TotalPlaytimeMinutes sql.NullInt64 `json:"total_playtime_minutes"`
}

func (q *Queries) GetTopPlayersByPlaytime(ctx context.Context, limit int64) ([]GetTopPlayersByPlaytimeRow, error) {
	rows, err := q.query(ctx, q.getTopPlayersByPlaytimeStmt, getTopPlayersByPlaytime, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopPlayersByPlaytimeRow{}
	for rows.Next() {
		var i GetTopPlayersByPlaytimeRow
		if err := rows.Scan(&i.Username, &i.TotalPlaytimeMinutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPlayersByResources = `-- name: GetTopPlayersByResources :many
SELECT p.username, ps.total_resources_harvested
FROM players p
JOIN player_stats ps ON p.player_id = ps.player_id
ORDER BY ps.total_resources_harvested DESC
LIMIT ?
`

type GetTopPlayersByResourcesRow struct {
	Username                string        `json:"username"`
	TotalResourcesHarvested sql.NullInt64 `json:"total_resources_harvested"`
}

func (q *Queries) GetTopPlayersByResources(ctx context.Context, limit int64) ([]GetTopPlayersByResourcesRow, error) {
	rows, err := q.query(ctx, q.getTopPlayersByResourcesStmt, getTopPlayersByResources, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopPlayersByResourcesRow{}
	for rows.Next() {
		var i GetTopPlayersByResourcesRow
		if err := rows.Scan(&i.Username, &i.TotalResourcesHarvested); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalResourcesInInventory = `-- name: GetTotalResourcesInInventory :one
SELECT COALESCE(SUM(quantity), 0) as total_resources
FROM player_inventories
WHERE player_id = ?
`

func (q *Queries) GetTotalResourcesInInventory(ctx context.Context, playerID int64) (interface{}, error) {
	row := q.queryRow(ctx, q.getTotalResourcesInInventoryStmt, getTotalResourcesInInventory, playerID)
	var total_resources interface{}
	err := row.Scan(&total_resources)
	return total_resources, err
}

const incrementPlayerSessions = `-- name: IncrementPlayerSessions :exec
UPDATE player_stats
SET sessions_count = sessions_count + 1,
    stats_updated = CURRENT_TIMESTAMP
WHERE player_id = ?
`

func (q *Queries) IncrementPlayerSessions(ctx context.Context, playerID int64) error {
	_, err := q.exec(ctx, q.incrementPlayerSessionsStmt, incrementPlayerSessions, playerID)
	return err
}

const removeFromPlayerInventory = `-- name: RemoveFromPlayerInventory :exec
UPDATE player_inventories
SET quantity = quantity - ?,
    last_updated = CURRENT_TIMESTAMP
WHERE player_id = ? AND resource_type = ? AND resource_subtype = ? AND quantity >= ?
`

type RemoveFromPlayerInventoryParams struct {
	Quantity        sql.NullInt64 `json:"quantity"`
	PlayerID        int64         `json:"player_id"`
	ResourceType    int64         `json:"resource_type"`
	ResourceSubtype sql.NullInt64 `json:"resource_subtype"`
	Quantity_2      sql.NullInt64 `json:"quantity_2"`
}

func (q *Queries) RemoveFromPlayerInventory(ctx context.Context, arg RemoveFromPlayerInventoryParams) error {
	_, err := q.exec(ctx, q.removeFromPlayerInventoryStmt, removeFromPlayerInventory,
		arg.Quantity,
		arg.PlayerID,
		arg.ResourceType,
		arg.ResourceSubtype,
		arg.Quantity_2,
	)
	return err
}

const setPlayerInventoryQuantity = `-- name: SetPlayerInventoryQuantity :exec
INSERT INTO player_inventories (player_id, resource_type, resource_subtype, quantity)
VALUES (?, ?, ?, ?)
ON CONFLICT(player_id, resource_type, resource_subtype) DO UPDATE SET
    quantity = excluded.quantity,
    last_updated = CURRENT_TIMESTAMP
`

type SetPlayerInventoryQuantityParams struct {
	PlayerID        int64         `json:"player_id"`
	ResourceType    int64         `json:"resource_type"`
	ResourceSubtype sql.NullInt64 `json:"resource_subtype"`
	Quantity        sql.NullInt64 `json:"quantity"`
}

func (q *Queries) SetPlayerInventoryQuantity(ctx context.Context, arg SetPlayerInventoryQuantityParams) error {
	_, err := q.exec(ctx, q.setPlayerInventoryQuantityStmt, setPlayerInventoryQuantity,
		arg.PlayerID,
		arg.ResourceType,
		arg.ResourceSubtype,
		arg.Quantity,
	)
	return err
}

const setPlayerOffline = `-- name: SetPlayerOffline :exec
UPDATE players
SET is_online = 0, last_logout = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE player_id = ?
`

func (q *Queries) SetPlayerOffline(ctx context.Context, playerID int64) error {
	_, err := q.exec(ctx, q.setPlayerOfflineStmt, setPlayerOffline, playerID)
	return err
}

const setPlayerOnline = `-- name: SetPlayerOnline :exec
UPDATE players
SET is_online = 1, last_login = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE player_id = ?
`

func (q *Queries) SetPlayerOnline(ctx context.Context, playerID int64) error {
	_, err := q.exec(ctx, q.setPlayerOnlineStmt, setPlayerOnline, playerID)
	return err
}

const updatePlayerEmail = `-- name: UpdatePlayerEmail :exec
UPDATE players
SET email = ?, updated_at = CURRENT_TIMESTAMP
WHERE player_id = ?
`

type UpdatePlayerEmailParams struct {
	Email    sql.NullString `json:"email"`
	PlayerID int64          `json:"player_id"`
}

func (q *Queries) UpdatePlayerEmail(ctx context.Context, arg UpdatePlayerEmailParams) error {
	_, err := q.exec(ctx, q.updatePlayerEmailStmt, updatePlayerEmail, arg.Email, arg.PlayerID)
	return err
}

const updatePlayerPassword = `-- name: UpdatePlayerPassword :exec
UPDATE players
SET password_hash = ?, salt = ?, updated_at = CURRENT_TIMESTAMP
WHERE player_id = ?
`

type UpdatePlayerPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	Salt         string `json:"salt"`
	PlayerID     int64  `json:"player_id"`
}

func (q *Queries) UpdatePlayerPassword(ctx context.Context, arg UpdatePlayerPasswordParams) error {
	_, err := q.exec(ctx, q.updatePlayerPasswordStmt, updatePlayerPassword, arg.PasswordHash, arg.Salt, arg.PlayerID)
	return err
}

const updatePlayerPlaytime = `-- name: UpdatePlayerPlaytime :exec
UPDATE player_stats
SET total_playtime_minutes = total_playtime_minutes + ?,
    stats_updated = CURRENT_TIMESTAMP
WHERE player_id = ?
`

type UpdatePlayerPlaytimeParams struct {
	TotalPlaytimeMinutes sql.NullInt64 `json:"total_playtime_minutes"`
	PlayerID             int64         `json:"player_id"`
}

func (q *Queries) UpdatePlayerPlaytime(ctx context.Context, arg UpdatePlayerPlaytimeParams) error {
	_, err := q.exec(ctx, q.updatePlayerPlaytimeStmt, updatePlayerPlaytime, arg.TotalPlaytimeMinutes, arg.PlayerID)
	return err
}

const updatePlayerPosition = `-- name: UpdatePlayerPosition :exec
UPDATE players
SET world_x = ?, world_y = ?, world_z = ?,
    current_chunk_x = ?, current_chunk_z = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE player_id = ?
`

type UpdatePlayerPositionParams struct {
	WorldX        sql.NullFloat64 `json:"world_x"`
	WorldY        sql.NullFloat64 `json:"world_y"`
	WorldZ        sql.NullFloat64 `json:"world_z"`
	CurrentChunkX sql.NullInt64   `json:"current_chunk_x"`
	CurrentChunkZ sql.NullInt64   `json:"current_chunk_z"`
	PlayerID      int64           `json:"player_id"`
}

func (q *Queries) UpdatePlayerPosition(ctx context.Context, arg UpdatePlayerPositionParams) error {
	_, err := q.exec(ctx, q.updatePlayerPositionStmt, updatePlayerPosition,
		arg.WorldX,
		arg.WorldY,
		arg.WorldZ,
		arg.CurrentChunkX,
		arg.CurrentChunkZ,
		arg.PlayerID,
	)
	return err
}

const updatePlayerSessionActivity = `-- name: UpdatePlayerSessionActivity :exec
UPDATE player_sessions
SET last_activity = CURRENT_TIMESTAMP
WHERE session_token = ?
`

func (q *Queries) UpdatePlayerSessionActivity(ctx context.Context, sessionToken string) error {
	_, err := q.exec(ctx, q.updatePlayerSessionActivityStmt, updatePlayerSessionActivity, sessionToken)
	return err
}

const updatePlayerStats = `-- name: UpdatePlayerStats :exec
UPDATE player_stats
SET total_resources_harvested = total_resources_harvested + ?,
    total_harvest_sessions = total_harvest_sessions + ?,
    iron_ore_harvested = iron_ore_harvested + ?,
    gold_ore_harvested = gold_ore_harvested + ?,
    wood_harvested = wood_harvested + ?,
    stone_harvested = stone_harvested + ?,
    unique_nodes_discovered = ?,
    total_nodes_harvested = total_nodes_harvested + ?,
    last_harvest = CURRENT_TIMESTAMP,
    stats_updated = CURRENT_TIMESTAMP
WHERE player_id = ?
`

type UpdatePlayerStatsParams struct {
	TotalResourcesHarvested sql.NullInt64 `json:"total_resources_harvested"`
	TotalHarvestSessions    sql.NullInt64 `json:"total_harvest_sessions"`
	IronOreHarvested        sql.NullInt64 `json:"iron_ore_harvested"`
	GoldOreHarvested        sql.NullInt64 `json:"gold_ore_harvested"`
	WoodHarvested           sql.NullInt64 `json:"wood_harvested"`
	StoneHarvested          sql.NullInt64 `json:"stone_harvested"`
	UniqueNodesDiscovered   sql.NullInt64 `json:"unique_nodes_discovered"`
	TotalNodesHarvested     sql.NullInt64 `json:"total_nodes_harvested"`
	PlayerID                int64         `json:"player_id"`
}

func (q *Queries) UpdatePlayerStats(ctx context.Context, arg UpdatePlayerStatsParams) error {
	_, err := q.exec(ctx, q.updatePlayerStatsStmt, updatePlayerStats,
		arg.TotalResourcesHarvested,
		arg.TotalHarvestSessions,
		arg.IronOreHarvested,
		arg.GoldOreHarvested,
		arg.WoodHarvested,
		arg.StoneHarvested,
		arg.UniqueNodesDiscovered,
		arg.TotalNodesHarvested,
		arg.PlayerID,
	)
	return err
}
