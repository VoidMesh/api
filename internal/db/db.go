// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.checkNodePositionStmt, err = db.PrepareContext(ctx, checkNodePosition); err != nil {
		return nil, fmt.Errorf("error preparing query CheckNodePosition: %w", err)
	}
	if q.cleanupExpiredSessionsStmt, err = db.PrepareContext(ctx, cleanupExpiredSessions); err != nil {
		return nil, fmt.Errorf("error preparing query CleanupExpiredSessions: %w", err)
	}
	if q.createChunkStmt, err = db.PrepareContext(ctx, createChunk); err != nil {
		return nil, fmt.Errorf("error preparing query CreateChunk: %w", err)
	}
	if q.createHarvestLogStmt, err = db.PrepareContext(ctx, createHarvestLog); err != nil {
		return nil, fmt.Errorf("error preparing query CreateHarvestLog: %w", err)
	}
	if q.createHarvestSessionStmt, err = db.PrepareContext(ctx, createHarvestSession); err != nil {
		return nil, fmt.Errorf("error preparing query CreateHarvestSession: %w", err)
	}
	if q.createNodeStmt, err = db.PrepareContext(ctx, createNode); err != nil {
		return nil, fmt.Errorf("error preparing query CreateNode: %w", err)
	}
	if q.deactivateNodeStmt, err = db.PrepareContext(ctx, deactivateNode); err != nil {
		return nil, fmt.Errorf("error preparing query DeactivateNode: %w", err)
	}
	if q.getChunkStmt, err = db.PrepareContext(ctx, getChunk); err != nil {
		return nil, fmt.Errorf("error preparing query GetChunk: %w", err)
	}
	if q.getChunkNodesStmt, err = db.PrepareContext(ctx, getChunkNodes); err != nil {
		return nil, fmt.Errorf("error preparing query GetChunkNodes: %w", err)
	}
	if q.getDailyNodeCountStmt, err = db.PrepareContext(ctx, getDailyNodeCount); err != nil {
		return nil, fmt.Errorf("error preparing query GetDailyNodeCount: %w", err)
	}
	if q.getHarvestSessionStmt, err = db.PrepareContext(ctx, getHarvestSession); err != nil {
		return nil, fmt.Errorf("error preparing query GetHarvestSession: %w", err)
	}
	if q.getNodeStmt, err = db.PrepareContext(ctx, getNode); err != nil {
		return nil, fmt.Errorf("error preparing query GetNode: %w", err)
	}
	if q.getNodesToRespawnStmt, err = db.PrepareContext(ctx, getNodesToRespawn); err != nil {
		return nil, fmt.Errorf("error preparing query GetNodesToRespawn: %w", err)
	}
	if q.getPlayerActiveSessionStmt, err = db.PrepareContext(ctx, getPlayerActiveSession); err != nil {
		return nil, fmt.Errorf("error preparing query GetPlayerActiveSession: %w", err)
	}
	if q.getPlayerSessionsStmt, err = db.PrepareContext(ctx, getPlayerSessions); err != nil {
		return nil, fmt.Errorf("error preparing query GetPlayerSessions: %w", err)
	}
	if q.getRandomNodeCountStmt, err = db.PrepareContext(ctx, getRandomNodeCount); err != nil {
		return nil, fmt.Errorf("error preparing query GetRandomNodeCount: %w", err)
	}
	if q.getRespawnDelayStmt, err = db.PrepareContext(ctx, getRespawnDelay); err != nil {
		return nil, fmt.Errorf("error preparing query GetRespawnDelay: %w", err)
	}
	if q.getSpawnTemplatesStmt, err = db.PrepareContext(ctx, getSpawnTemplates); err != nil {
		return nil, fmt.Errorf("error preparing query GetSpawnTemplates: %w", err)
	}
	if q.reactivateNodeStmt, err = db.PrepareContext(ctx, reactivateNode); err != nil {
		return nil, fmt.Errorf("error preparing query ReactivateNode: %w", err)
	}
	if q.regenerateNodeYieldStmt, err = db.PrepareContext(ctx, regenerateNodeYield); err != nil {
		return nil, fmt.Errorf("error preparing query RegenerateNodeYield: %w", err)
	}
	if q.updateChunkModifiedStmt, err = db.PrepareContext(ctx, updateChunkModified); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateChunkModified: %w", err)
	}
	if q.updateNodeYieldStmt, err = db.PrepareContext(ctx, updateNodeYield); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateNodeYield: %w", err)
	}
	if q.updateSessionActivityStmt, err = db.PrepareContext(ctx, updateSessionActivity); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateSessionActivity: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.checkNodePositionStmt != nil {
		if cerr := q.checkNodePositionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing checkNodePositionStmt: %w", cerr)
		}
	}
	if q.cleanupExpiredSessionsStmt != nil {
		if cerr := q.cleanupExpiredSessionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing cleanupExpiredSessionsStmt: %w", cerr)
		}
	}
	if q.createChunkStmt != nil {
		if cerr := q.createChunkStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createChunkStmt: %w", cerr)
		}
	}
	if q.createHarvestLogStmt != nil {
		if cerr := q.createHarvestLogStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createHarvestLogStmt: %w", cerr)
		}
	}
	if q.createHarvestSessionStmt != nil {
		if cerr := q.createHarvestSessionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createHarvestSessionStmt: %w", cerr)
		}
	}
	if q.createNodeStmt != nil {
		if cerr := q.createNodeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createNodeStmt: %w", cerr)
		}
	}
	if q.deactivateNodeStmt != nil {
		if cerr := q.deactivateNodeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deactivateNodeStmt: %w", cerr)
		}
	}
	if q.getChunkStmt != nil {
		if cerr := q.getChunkStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getChunkStmt: %w", cerr)
		}
	}
	if q.getChunkNodesStmt != nil {
		if cerr := q.getChunkNodesStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getChunkNodesStmt: %w", cerr)
		}
	}
	if q.getDailyNodeCountStmt != nil {
		if cerr := q.getDailyNodeCountStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getDailyNodeCountStmt: %w", cerr)
		}
	}
	if q.getHarvestSessionStmt != nil {
		if cerr := q.getHarvestSessionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getHarvestSessionStmt: %w", cerr)
		}
	}
	if q.getNodeStmt != nil {
		if cerr := q.getNodeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getNodeStmt: %w", cerr)
		}
	}
	if q.getNodesToRespawnStmt != nil {
		if cerr := q.getNodesToRespawnStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getNodesToRespawnStmt: %w", cerr)
		}
	}
	if q.getPlayerActiveSessionStmt != nil {
		if cerr := q.getPlayerActiveSessionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getPlayerActiveSessionStmt: %w", cerr)
		}
	}
	if q.getPlayerSessionsStmt != nil {
		if cerr := q.getPlayerSessionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getPlayerSessionsStmt: %w", cerr)
		}
	}
	if q.getRandomNodeCountStmt != nil {
		if cerr := q.getRandomNodeCountStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getRandomNodeCountStmt: %w", cerr)
		}
	}
	if q.getRespawnDelayStmt != nil {
		if cerr := q.getRespawnDelayStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getRespawnDelayStmt: %w", cerr)
		}
	}
	if q.getSpawnTemplatesStmt != nil {
		if cerr := q.getSpawnTemplatesStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSpawnTemplatesStmt: %w", cerr)
		}
	}
	if q.reactivateNodeStmt != nil {
		if cerr := q.reactivateNodeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing reactivateNodeStmt: %w", cerr)
		}
	}
	if q.regenerateNodeYieldStmt != nil {
		if cerr := q.regenerateNodeYieldStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing regenerateNodeYieldStmt: %w", cerr)
		}
	}
	if q.updateChunkModifiedStmt != nil {
		if cerr := q.updateChunkModifiedStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateChunkModifiedStmt: %w", cerr)
		}
	}
	if q.updateNodeYieldStmt != nil {
		if cerr := q.updateNodeYieldStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateNodeYieldStmt: %w", cerr)
		}
	}
	if q.updateSessionActivityStmt != nil {
		if cerr := q.updateSessionActivityStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateSessionActivityStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                         DBTX
	tx                         *sql.Tx
	checkNodePositionStmt      *sql.Stmt
	cleanupExpiredSessionsStmt *sql.Stmt
	createChunkStmt            *sql.Stmt
	createHarvestLogStmt       *sql.Stmt
	createHarvestSessionStmt   *sql.Stmt
	createNodeStmt             *sql.Stmt
	deactivateNodeStmt         *sql.Stmt
	getChunkStmt               *sql.Stmt
	getChunkNodesStmt          *sql.Stmt
	getDailyNodeCountStmt      *sql.Stmt
	getHarvestSessionStmt      *sql.Stmt
	getNodeStmt                *sql.Stmt
	getNodesToRespawnStmt      *sql.Stmt
	getPlayerActiveSessionStmt *sql.Stmt
	getPlayerSessionsStmt      *sql.Stmt
	getRandomNodeCountStmt     *sql.Stmt
	getRespawnDelayStmt        *sql.Stmt
	getSpawnTemplatesStmt      *sql.Stmt
	reactivateNodeStmt         *sql.Stmt
	regenerateNodeYieldStmt    *sql.Stmt
	updateChunkModifiedStmt    *sql.Stmt
	updateNodeYieldStmt        *sql.Stmt
	updateSessionActivityStmt  *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                         tx,
		tx:                         tx,
		checkNodePositionStmt:      q.checkNodePositionStmt,
		cleanupExpiredSessionsStmt: q.cleanupExpiredSessionsStmt,
		createChunkStmt:            q.createChunkStmt,
		createHarvestLogStmt:       q.createHarvestLogStmt,
		createHarvestSessionStmt:   q.createHarvestSessionStmt,
		createNodeStmt:             q.createNodeStmt,
		deactivateNodeStmt:         q.deactivateNodeStmt,
		getChunkStmt:               q.getChunkStmt,
		getChunkNodesStmt:          q.getChunkNodesStmt,
		getDailyNodeCountStmt:      q.getDailyNodeCountStmt,
		getHarvestSessionStmt:      q.getHarvestSessionStmt,
		getNodeStmt:                q.getNodeStmt,
		getNodesToRespawnStmt:      q.getNodesToRespawnStmt,
		getPlayerActiveSessionStmt: q.getPlayerActiveSessionStmt,
		getPlayerSessionsStmt:      q.getPlayerSessionsStmt,
		getRandomNodeCountStmt:     q.getRandomNodeCountStmt,
		getRespawnDelayStmt:        q.getRespawnDelayStmt,
		getSpawnTemplatesStmt:      q.getSpawnTemplatesStmt,
		reactivateNodeStmt:         q.reactivateNodeStmt,
		regenerateNodeYieldStmt:    q.regenerateNodeYieldStmt,
		updateChunkModifiedStmt:    q.updateChunkModifiedStmt,
		updateNodeYieldStmt:        q.updateNodeYieldStmt,
		updateSessionActivityStmt:  q.updateSessionActivityStmt,
	}
}
