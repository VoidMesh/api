// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: resource_nodes.sql

package db

import (
	"context"
	"database/sql"
)

const checkNodePosition = `-- name: CheckNodePosition :one
SELECT COUNT(*) FROM resource_nodes
WHERE chunk_x = ? AND chunk_z = ? AND local_x = ? AND local_z = ? AND is_active = 1
`

type CheckNodePositionParams struct {
	ChunkX int64 `json:"chunk_x"`
	ChunkZ int64 `json:"chunk_z"`
	LocalX int64 `json:"local_x"`
	LocalZ int64 `json:"local_z"`
}

func (q *Queries) CheckNodePosition(ctx context.Context, arg CheckNodePositionParams) (int64, error) {
	row := q.queryRow(ctx, q.checkNodePositionStmt, checkNodePosition,
		arg.ChunkX,
		arg.ChunkZ,
		arg.LocalX,
		arg.LocalZ,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNode = `-- name: CreateNode :one
INSERT INTO resource_nodes (chunk_x, chunk_z, local_x, local_z, node_type, node_subtype, max_yield, current_yield, regeneration_rate, spawn_type)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING node_id
`

type CreateNodeParams struct {
	ChunkX           int64         `json:"chunk_x"`
	ChunkZ           int64         `json:"chunk_z"`
	LocalX           int64         `json:"local_x"`
	LocalZ           int64         `json:"local_z"`
	NodeType         int64         `json:"node_type"`
	NodeSubtype      sql.NullInt64 `json:"node_subtype"`
	MaxYield         int64         `json:"max_yield"`
	CurrentYield     int64         `json:"current_yield"`
	RegenerationRate sql.NullInt64 `json:"regeneration_rate"`
	SpawnType        int64         `json:"spawn_type"`
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (int64, error) {
	row := q.queryRow(ctx, q.createNodeStmt, createNode,
		arg.ChunkX,
		arg.ChunkZ,
		arg.LocalX,
		arg.LocalZ,
		arg.NodeType,
		arg.NodeSubtype,
		arg.MaxYield,
		arg.CurrentYield,
		arg.RegenerationRate,
		arg.SpawnType,
	)
	var node_id int64
	err := row.Scan(&node_id)
	return node_id, err
}

const deactivateNode = `-- name: DeactivateNode :exec
UPDATE resource_nodes SET is_active = 0, respawn_timer = ? WHERE node_id = ?
`

type DeactivateNodeParams struct {
	RespawnTimer sql.NullTime `json:"respawn_timer"`
	NodeID       int64        `json:"node_id"`
}

func (q *Queries) DeactivateNode(ctx context.Context, arg DeactivateNodeParams) error {
	_, err := q.exec(ctx, q.deactivateNodeStmt, deactivateNode, arg.RespawnTimer, arg.NodeID)
	return err
}

const getChunkNodes = `-- name: GetChunkNodes :many
SELECT node_id, chunk_x, chunk_z, local_x, local_z, node_type, node_subtype,
       max_yield, current_yield, regeneration_rate, spawned_at, last_harvest,
       respawn_timer, spawn_type, is_active
FROM resource_nodes
WHERE chunk_x = ? AND chunk_z = ? AND is_active = 1
`

type GetChunkNodesParams struct {
	ChunkX int64 `json:"chunk_x"`
	ChunkZ int64 `json:"chunk_z"`
}

func (q *Queries) GetChunkNodes(ctx context.Context, arg GetChunkNodesParams) ([]ResourceNode, error) {
	rows, err := q.query(ctx, q.getChunkNodesStmt, getChunkNodes, arg.ChunkX, arg.ChunkZ)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ResourceNode{}
	for rows.Next() {
		var i ResourceNode
		if err := rows.Scan(
			&i.NodeID,
			&i.ChunkX,
			&i.ChunkZ,
			&i.LocalX,
			&i.LocalZ,
			&i.NodeType,
			&i.NodeSubtype,
			&i.MaxYield,
			&i.CurrentYield,
			&i.RegenerationRate,
			&i.SpawnedAt,
			&i.LastHarvest,
			&i.RespawnTimer,
			&i.SpawnType,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyNodeCount = `-- name: GetDailyNodeCount :one
SELECT COUNT(*) FROM resource_nodes
WHERE chunk_x = ? AND chunk_z = ? AND spawn_type = 1 AND DATE(spawned_at) = ?
`

type GetDailyNodeCountParams struct {
	ChunkX    int64        `json:"chunk_x"`
	ChunkZ    int64        `json:"chunk_z"`
	SpawnedAt sql.NullTime `json:"spawned_at"`
}

func (q *Queries) GetDailyNodeCount(ctx context.Context, arg GetDailyNodeCountParams) (int64, error) {
	row := q.queryRow(ctx, q.getDailyNodeCountStmt, getDailyNodeCount, arg.ChunkX, arg.ChunkZ, arg.SpawnedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNode = `-- name: GetNode :one
SELECT node_id, chunk_x, chunk_z, local_x, local_z, node_type, node_subtype,
       max_yield, current_yield, regeneration_rate, spawned_at, last_harvest,
       respawn_timer, spawn_type, is_active
FROM resource_nodes
WHERE node_id = ?
`

func (q *Queries) GetNode(ctx context.Context, nodeID int64) (ResourceNode, error) {
	row := q.queryRow(ctx, q.getNodeStmt, getNode, nodeID)
	var i ResourceNode
	err := row.Scan(
		&i.NodeID,
		&i.ChunkX,
		&i.ChunkZ,
		&i.LocalX,
		&i.LocalZ,
		&i.NodeType,
		&i.NodeSubtype,
		&i.MaxYield,
		&i.CurrentYield,
		&i.RegenerationRate,
		&i.SpawnedAt,
		&i.LastHarvest,
		&i.RespawnTimer,
		&i.SpawnType,
		&i.IsActive,
	)
	return i, err
}

const getNodesToRespawn = `-- name: GetNodesToRespawn :many
SELECT node_id, max_yield FROM resource_nodes
WHERE chunk_x = ? AND chunk_z = ? AND is_active = 0 AND respawn_timer IS NOT NULL AND respawn_timer <= ?
`

type GetNodesToRespawnParams struct {
	ChunkX       int64        `json:"chunk_x"`
	ChunkZ       int64        `json:"chunk_z"`
	RespawnTimer sql.NullTime `json:"respawn_timer"`
}

type GetNodesToRespawnRow struct {
	NodeID   int64 `json:"node_id"`
	MaxYield int64 `json:"max_yield"`
}

func (q *Queries) GetNodesToRespawn(ctx context.Context, arg GetNodesToRespawnParams) ([]GetNodesToRespawnRow, error) {
	rows, err := q.query(ctx, q.getNodesToRespawnStmt, getNodesToRespawn, arg.ChunkX, arg.ChunkZ, arg.RespawnTimer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNodesToRespawnRow{}
	for rows.Next() {
		var i GetNodesToRespawnRow
		if err := rows.Scan(&i.NodeID, &i.MaxYield); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomNodeCount = `-- name: GetRandomNodeCount :one
SELECT COUNT(*) FROM resource_nodes
WHERE chunk_x = ? AND chunk_z = ? AND spawn_type = 0 AND is_active = 1
`

type GetRandomNodeCountParams struct {
	ChunkX int64 `json:"chunk_x"`
	ChunkZ int64 `json:"chunk_z"`
}

func (q *Queries) GetRandomNodeCount(ctx context.Context, arg GetRandomNodeCountParams) (int64, error) {
	row := q.queryRow(ctx, q.getRandomNodeCountStmt, getRandomNodeCount, arg.ChunkX, arg.ChunkZ)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const reactivateNode = `-- name: ReactivateNode :exec
UPDATE resource_nodes SET current_yield = ?, is_active = 1, respawn_timer = NULL, spawned_at = CURRENT_TIMESTAMP WHERE node_id = ?
`

type ReactivateNodeParams struct {
	CurrentYield int64 `json:"current_yield"`
	NodeID       int64 `json:"node_id"`
}

func (q *Queries) ReactivateNode(ctx context.Context, arg ReactivateNodeParams) error {
	_, err := q.exec(ctx, q.reactivateNodeStmt, reactivateNode, arg.CurrentYield, arg.NodeID)
	return err
}

const regenerateNodeYield = `-- name: RegenerateNodeYield :exec
UPDATE resource_nodes
SET current_yield = MIN(current_yield + regeneration_rate, max_yield)
WHERE regeneration_rate > 0 AND is_active = 1 AND current_yield < max_yield
`

func (q *Queries) RegenerateNodeYield(ctx context.Context) error {
	_, err := q.exec(ctx, q.regenerateNodeYieldStmt, regenerateNodeYield)
	return err
}

const updateNodeYield = `-- name: UpdateNodeYield :exec
UPDATE resource_nodes SET current_yield = ?, last_harvest = CURRENT_TIMESTAMP WHERE node_id = ?
`

type UpdateNodeYieldParams struct {
	CurrentYield int64 `json:"current_yield"`
	NodeID       int64 `json:"node_id"`
}

func (q *Queries) UpdateNodeYield(ctx context.Context, arg UpdateNodeYieldParams) error {
	_, err := q.exec(ctx, q.updateNodeYieldStmt, updateNodeYield, arg.CurrentYield, arg.NodeID)
	return err
}
