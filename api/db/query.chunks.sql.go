// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.chunks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const chunkExists = `-- name: ChunkExists :one
SELECT EXISTS(
    SELECT 1 FROM chunks
    WHERE world_id = $1 AND chunk_x = $2 AND chunk_y = $3
)
`

type ChunkExistsParams struct {
	WorldID pgtype.UUID
	ChunkX  int32
	ChunkY  int32
}

func (q *Queries) ChunkExists(ctx context.Context, arg ChunkExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, chunkExists, arg.WorldID, arg.ChunkX, arg.ChunkY)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (world_id, chunk_x, chunk_y, chunk_data)
VALUES ($1, $2, $3, $4)
RETURNING world_id, chunk_x, chunk_y, chunk_data, generated_at
`

type CreateChunkParams struct {
	WorldID   pgtype.UUID
	ChunkX    int32
	ChunkY    int32
	ChunkData []byte
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (Chunk, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.WorldID,
		arg.ChunkX,
		arg.ChunkY,
		arg.ChunkData,
	)
	var i Chunk
	err := row.Scan(
		&i.WorldID,
		&i.ChunkX,
		&i.ChunkY,
		&i.ChunkData,
		&i.GeneratedAt,
	)
	return i, err
}

const deleteChunk = `-- name: DeleteChunk :exec
DELETE FROM chunks
WHERE world_id = $1 AND chunk_x = $2 AND chunk_y = $3
`

type DeleteChunkParams struct {
	WorldID pgtype.UUID
	ChunkX  int32
	ChunkY  int32
}

func (q *Queries) DeleteChunk(ctx context.Context, arg DeleteChunkParams) error {
	_, err := q.db.Exec(ctx, deleteChunk, arg.WorldID, arg.ChunkX, arg.ChunkY)
	return err
}

const getChunk = `-- name: GetChunk :one
SELECT world_id, chunk_x, chunk_y, chunk_data, generated_at FROM chunks
WHERE world_id = $1 AND chunk_x = $2 AND chunk_y = $3
`

type GetChunkParams struct {
	WorldID pgtype.UUID
	ChunkX  int32
	ChunkY  int32
}

func (q *Queries) GetChunk(ctx context.Context, arg GetChunkParams) (Chunk, error) {
	row := q.db.QueryRow(ctx, getChunk, arg.WorldID, arg.ChunkX, arg.ChunkY)
	var i Chunk
	err := row.Scan(
		&i.WorldID,
		&i.ChunkX,
		&i.ChunkY,
		&i.ChunkData,
		&i.GeneratedAt,
	)
	return i, err
}

const getChunks = `-- name: GetChunks :many
SELECT world_id, chunk_x, chunk_y, chunk_data, generated_at FROM chunks
WHERE world_id = $1
AND chunk_x >= $2 AND chunk_x <= $3 
AND chunk_y >= $4 AND chunk_y <= $5
ORDER BY chunk_x, chunk_y
`

type GetChunksParams struct {
	WorldID  pgtype.UUID
	ChunkX   int32
	ChunkX_2 int32
	ChunkY   int32
	ChunkY_2 int32
}

func (q *Queries) GetChunks(ctx context.Context, arg GetChunksParams) ([]Chunk, error) {
	rows, err := q.db.Query(ctx, getChunks,
		arg.WorldID,
		arg.ChunkX,
		arg.ChunkX_2,
		arg.ChunkY,
		arg.ChunkY_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chunk
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.WorldID,
			&i.ChunkX,
			&i.ChunkY,
			&i.ChunkData,
			&i.GeneratedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
