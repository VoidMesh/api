// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.resources.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countResourceNodesByType = `-- name: CountResourceNodesByType :one
SELECT COUNT(*) FROM resource_nodes
WHERE chunk_x = $1 AND chunk_y = $2 AND resource_type_id = $3
`

type CountResourceNodesByTypeParams struct {
	ChunkX         int32
	ChunkY         int32
	ResourceTypeID int32
}

func (q *Queries) CountResourceNodesByType(ctx context.Context, arg CountResourceNodesByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countResourceNodesByType, arg.ChunkX, arg.ChunkY, arg.ResourceTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countResourceNodesInChunk = `-- name: CountResourceNodesInChunk :one
SELECT COUNT(*) FROM resource_nodes
WHERE chunk_x = $1 AND chunk_y = $2
`

type CountResourceNodesInChunkParams struct {
	ChunkX int32
	ChunkY int32
}

func (q *Queries) CountResourceNodesInChunk(ctx context.Context, arg CountResourceNodesInChunkParams) (int64, error) {
	row := q.db.QueryRow(ctx, countResourceNodesInChunk, arg.ChunkX, arg.ChunkY)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createResourceNode = `-- name: CreateResourceNode :one

INSERT INTO resource_nodes (
  resource_type_id, 
  chunk_x, 
  chunk_y, 
  cluster_id, 
  pos_x, 
  pos_y,
  size
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, resource_type_id, chunk_x, chunk_y, cluster_id, pos_x, pos_y, size, created_at
`

type CreateResourceNodeParams struct {
	ResourceTypeID int32
	ChunkX         int32
	ChunkY         int32
	ClusterID      string
	PosX           int32
	PosY           int32
	Size           int32
}

// Resource Node Operations
func (q *Queries) CreateResourceNode(ctx context.Context, arg CreateResourceNodeParams) (ResourceNode, error) {
	row := q.db.QueryRow(ctx, createResourceNode,
		arg.ResourceTypeID,
		arg.ChunkX,
		arg.ChunkY,
		arg.ClusterID,
		arg.PosX,
		arg.PosY,
		arg.Size,
	)
	var i ResourceNode
	err := row.Scan(
		&i.ID,
		&i.ResourceTypeID,
		&i.ChunkX,
		&i.ChunkY,
		&i.ClusterID,
		&i.PosX,
		&i.PosY,
		&i.Size,
		&i.CreatedAt,
	)
	return i, err
}

const createResourceType = `-- name: CreateResourceType :one

INSERT INTO resource_types (name, description, terrain_type, rarity, visual_data, properties)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, description, terrain_type, rarity, visual_data, properties, created_at
`

type CreateResourceTypeParams struct {
	Name        string
	Description pgtype.Text
	TerrainType string
	Rarity      string
	VisualData  []byte
	Properties  []byte
}

// Resource Type Operations
func (q *Queries) CreateResourceType(ctx context.Context, arg CreateResourceTypeParams) (ResourceType, error) {
	row := q.db.QueryRow(ctx, createResourceType,
		arg.Name,
		arg.Description,
		arg.TerrainType,
		arg.Rarity,
		arg.VisualData,
		arg.Properties,
	)
	var i ResourceType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TerrainType,
		&i.Rarity,
		&i.VisualData,
		&i.Properties,
		&i.CreatedAt,
	)
	return i, err
}

const deleteResourceNodesInChunk = `-- name: DeleteResourceNodesInChunk :exec
DELETE FROM resource_nodes
WHERE chunk_x = $1 AND chunk_y = $2
`

type DeleteResourceNodesInChunkParams struct {
	ChunkX int32
	ChunkY int32
}

func (q *Queries) DeleteResourceNodesInChunk(ctx context.Context, arg DeleteResourceNodesInChunkParams) error {
	_, err := q.db.Exec(ctx, deleteResourceNodesInChunk, arg.ChunkX, arg.ChunkY)
	return err
}

const deleteResourceType = `-- name: DeleteResourceType :exec
DELETE FROM resource_types
WHERE id = $1
`

func (q *Queries) DeleteResourceType(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteResourceType, id)
	return err
}

const getResourceNode = `-- name: GetResourceNode :one
SELECT
  rn.id, rn.resource_type_id, rn.chunk_x, rn.chunk_y, rn.cluster_id, rn.pos_x, rn.pos_y, rn.size, rn.created_at,
  rt.name as resource_name,
  rt.terrain_type,
  rt.rarity
FROM resource_nodes rn
JOIN resource_types rt ON rn.resource_type_id = rt.id
WHERE rn.id = $1
`

type GetResourceNodeRow struct {
	ID             int32
	ResourceTypeID int32
	ChunkX         int32
	ChunkY         int32
	ClusterID      string
	PosX           int32
	PosY           int32
	Size           int32
	CreatedAt      pgtype.Timestamp
	ResourceName   string
	TerrainType    string
	Rarity         string
}

func (q *Queries) GetResourceNode(ctx context.Context, id int32) (GetResourceNodeRow, error) {
	row := q.db.QueryRow(ctx, getResourceNode, id)
	var i GetResourceNodeRow
	err := row.Scan(
		&i.ID,
		&i.ResourceTypeID,
		&i.ChunkX,
		&i.ChunkY,
		&i.ClusterID,
		&i.PosX,
		&i.PosY,
		&i.Size,
		&i.CreatedAt,
		&i.ResourceName,
		&i.TerrainType,
		&i.Rarity,
	)
	return i, err
}

const getResourceNodesInChunk = `-- name: GetResourceNodesInChunk :many
SELECT
  rn.id, rn.resource_type_id, rn.chunk_x, rn.chunk_y, rn.cluster_id, rn.pos_x, rn.pos_y, rn.size, rn.created_at,
  rt.name as resource_name,
  rt.terrain_type,
  rt.rarity
FROM resource_nodes rn
JOIN resource_types rt ON rn.resource_type_id = rt.id
WHERE rn.chunk_x = $1 AND rn.chunk_y = $2
`

type GetResourceNodesInChunkParams struct {
	ChunkX int32
	ChunkY int32
}

type GetResourceNodesInChunkRow struct {
	ID             int32
	ResourceTypeID int32
	ChunkX         int32
	ChunkY         int32
	ClusterID      string
	PosX           int32
	PosY           int32
	Size           int32
	CreatedAt      pgtype.Timestamp
	ResourceName   string
	TerrainType    string
	Rarity         string
}

func (q *Queries) GetResourceNodesInChunk(ctx context.Context, arg GetResourceNodesInChunkParams) ([]GetResourceNodesInChunkRow, error) {
	rows, err := q.db.Query(ctx, getResourceNodesInChunk, arg.ChunkX, arg.ChunkY)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceNodesInChunkRow
	for rows.Next() {
		var i GetResourceNodesInChunkRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceTypeID,
			&i.ChunkX,
			&i.ChunkY,
			&i.ClusterID,
			&i.PosX,
			&i.PosY,
			&i.Size,
			&i.CreatedAt,
			&i.ResourceName,
			&i.TerrainType,
			&i.Rarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceNodesInChunkRange = `-- name: GetResourceNodesInChunkRange :many
SELECT
  rn.id, rn.resource_type_id, rn.chunk_x, rn.chunk_y, rn.cluster_id, rn.pos_x, rn.pos_y, rn.size, rn.created_at,
  rt.name as resource_name,
  rt.terrain_type,
  rt.rarity
FROM resource_nodes rn
JOIN resource_types rt ON rn.resource_type_id = rt.id
WHERE rn.chunk_x >= $1 AND rn.chunk_x <= $2 AND
      rn.chunk_y >= $3 AND rn.chunk_y <= $4
`

type GetResourceNodesInChunkRangeParams struct {
	ChunkX   int32
	ChunkX_2 int32
	ChunkY   int32
	ChunkY_2 int32
}

type GetResourceNodesInChunkRangeRow struct {
	ID             int32
	ResourceTypeID int32
	ChunkX         int32
	ChunkY         int32
	ClusterID      string
	PosX           int32
	PosY           int32
	Size           int32
	CreatedAt      pgtype.Timestamp
	ResourceName   string
	TerrainType    string
	Rarity         string
}

func (q *Queries) GetResourceNodesInChunkRange(ctx context.Context, arg GetResourceNodesInChunkRangeParams) ([]GetResourceNodesInChunkRangeRow, error) {
	rows, err := q.db.Query(ctx, getResourceNodesInChunkRange,
		arg.ChunkX,
		arg.ChunkX_2,
		arg.ChunkY,
		arg.ChunkY_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceNodesInChunkRangeRow
	for rows.Next() {
		var i GetResourceNodesInChunkRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceTypeID,
			&i.ChunkX,
			&i.ChunkY,
			&i.ClusterID,
			&i.PosX,
			&i.PosY,
			&i.Size,
			&i.CreatedAt,
			&i.ResourceName,
			&i.TerrainType,
			&i.Rarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceNodesInChunks = `-- name: GetResourceNodesInChunks :many
SELECT
  rn.id, rn.resource_type_id, rn.chunk_x, rn.chunk_y, rn.cluster_id, rn.pos_x, rn.pos_y, rn.size, rn.created_at,
  rt.name as resource_name,
  rt.terrain_type,
  rt.rarity
FROM resource_nodes rn
JOIN resource_types rt ON rn.resource_type_id = rt.id
WHERE (rn.chunk_x = $1 AND rn.chunk_y = $2) OR
      (rn.chunk_x = $3 AND rn.chunk_y = $4) OR
      (rn.chunk_x = $5 AND rn.chunk_y = $6) OR
      (rn.chunk_x = $7 AND rn.chunk_y = $8) OR
      (rn.chunk_x = $9 AND rn.chunk_y = $10)
`

type GetResourceNodesInChunksParams struct {
	ChunkX   int32
	ChunkY   int32
	ChunkX_2 int32
	ChunkY_2 int32
	ChunkX_3 int32
	ChunkY_3 int32
	ChunkX_4 int32
	ChunkY_4 int32
	ChunkX_5 int32
	ChunkY_5 int32
}

type GetResourceNodesInChunksRow struct {
	ID             int32
	ResourceTypeID int32
	ChunkX         int32
	ChunkY         int32
	ClusterID      string
	PosX           int32
	PosY           int32
	Size           int32
	CreatedAt      pgtype.Timestamp
	ResourceName   string
	TerrainType    string
	Rarity         string
}

func (q *Queries) GetResourceNodesInChunks(ctx context.Context, arg GetResourceNodesInChunksParams) ([]GetResourceNodesInChunksRow, error) {
	rows, err := q.db.Query(ctx, getResourceNodesInChunks,
		arg.ChunkX,
		arg.ChunkY,
		arg.ChunkX_2,
		arg.ChunkY_2,
		arg.ChunkX_3,
		arg.ChunkY_3,
		arg.ChunkX_4,
		arg.ChunkY_4,
		arg.ChunkX_5,
		arg.ChunkY_5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceNodesInChunksRow
	for rows.Next() {
		var i GetResourceNodesInChunksRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceTypeID,
			&i.ChunkX,
			&i.ChunkY,
			&i.ClusterID,
			&i.PosX,
			&i.PosY,
			&i.Size,
			&i.CreatedAt,
			&i.ResourceName,
			&i.TerrainType,
			&i.Rarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceNodesInCluster = `-- name: GetResourceNodesInCluster :many
SELECT
  rn.id, rn.resource_type_id, rn.chunk_x, rn.chunk_y, rn.cluster_id, rn.pos_x, rn.pos_y, rn.size, rn.created_at,
  rt.name as resource_name,
  rt.terrain_type,
  rt.rarity
FROM resource_nodes rn
JOIN resource_types rt ON rn.resource_type_id = rt.id
WHERE rn.cluster_id = $1
`

type GetResourceNodesInClusterRow struct {
	ID             int32
	ResourceTypeID int32
	ChunkX         int32
	ChunkY         int32
	ClusterID      string
	PosX           int32
	PosY           int32
	Size           int32
	CreatedAt      pgtype.Timestamp
	ResourceName   string
	TerrainType    string
	Rarity         string
}

func (q *Queries) GetResourceNodesInCluster(ctx context.Context, clusterID string) ([]GetResourceNodesInClusterRow, error) {
	rows, err := q.db.Query(ctx, getResourceNodesInCluster, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceNodesInClusterRow
	for rows.Next() {
		var i GetResourceNodesInClusterRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceTypeID,
			&i.ChunkX,
			&i.ChunkY,
			&i.ClusterID,
			&i.PosX,
			&i.PosY,
			&i.Size,
			&i.CreatedAt,
			&i.ResourceName,
			&i.TerrainType,
			&i.Rarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceType = `-- name: GetResourceType :one
SELECT id, name, description, terrain_type, rarity, visual_data, properties, created_at FROM resource_types
WHERE id = $1
`

func (q *Queries) GetResourceType(ctx context.Context, id int32) (ResourceType, error) {
	row := q.db.QueryRow(ctx, getResourceType, id)
	var i ResourceType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TerrainType,
		&i.Rarity,
		&i.VisualData,
		&i.Properties,
		&i.CreatedAt,
	)
	return i, err
}

const listResourceTypes = `-- name: ListResourceTypes :many
SELECT id, name, description, terrain_type, rarity, visual_data, properties, created_at FROM resource_types
ORDER BY name
`

func (q *Queries) ListResourceTypes(ctx context.Context) ([]ResourceType, error) {
	rows, err := q.db.Query(ctx, listResourceTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ResourceType
	for rows.Next() {
		var i ResourceType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.TerrainType,
			&i.Rarity,
			&i.VisualData,
			&i.Properties,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceTypesByTerrain = `-- name: ListResourceTypesByTerrain :many
SELECT id, name, description, terrain_type, rarity, visual_data, properties, created_at FROM resource_types
WHERE terrain_type = $1
ORDER BY name
`

func (q *Queries) ListResourceTypesByTerrain(ctx context.Context, terrainType string) ([]ResourceType, error) {
	rows, err := q.db.Query(ctx, listResourceTypesByTerrain, terrainType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ResourceType
	for rows.Next() {
		var i ResourceType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.TerrainType,
			&i.Rarity,
			&i.VisualData,
			&i.Properties,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resourceExistsAtPosition = `-- name: ResourceExistsAtPosition :one
SELECT EXISTS(
  SELECT 1 FROM resource_nodes
  WHERE chunk_x = $1 AND chunk_y = $2 AND pos_x = $3 AND pos_y = $4
)
`

type ResourceExistsAtPositionParams struct {
	ChunkX int32
	ChunkY int32
	PosX   int32
	PosY   int32
}

func (q *Queries) ResourceExistsAtPosition(ctx context.Context, arg ResourceExistsAtPositionParams) (bool, error) {
	row := q.db.QueryRow(ctx, resourceExistsAtPosition,
		arg.ChunkX,
		arg.ChunkY,
		arg.PosX,
		arg.PosY,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateResourceType = `-- name: UpdateResourceType :one
UPDATE resource_types
SET 
  name = $2,
  description = $3,
  terrain_type = $4,
  rarity = $5,
  visual_data = $6,
  properties = $7
WHERE id = $1
RETURNING id, name, description, terrain_type, rarity, visual_data, properties, created_at
`

type UpdateResourceTypeParams struct {
	ID          int32
	Name        string
	Description pgtype.Text
	TerrainType string
	Rarity      string
	VisualData  []byte
	Properties  []byte
}

func (q *Queries) UpdateResourceType(ctx context.Context, arg UpdateResourceTypeParams) (ResourceType, error) {
	row := q.db.QueryRow(ctx, updateResourceType,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.TerrainType,
		arg.Rarity,
		arg.VisualData,
		arg.Properties,
	)
	var i ResourceType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TerrainType,
		&i.Rarity,
		&i.VisualData,
		&i.Properties,
		&i.CreatedAt,
	)
	return i, err
}
