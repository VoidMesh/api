// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.inventory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addInventoryItemQuantity = `-- name: AddInventoryItemQuantity :one
UPDATE character_inventories
SET 
  quantity = quantity + $3,
  updated_at = NOW()
WHERE character_id = $1 AND item_id = $2
RETURNING id, character_id, item_id, quantity, created_at, updated_at
`

type AddInventoryItemQuantityParams struct {
	CharacterID pgtype.UUID
	ItemID      int32
	Quantity    int32
}

func (q *Queries) AddInventoryItemQuantity(ctx context.Context, arg AddInventoryItemQuantityParams) (CharacterInventory, error) {
	row := q.db.QueryRow(ctx, addInventoryItemQuantity, arg.CharacterID, arg.ItemID, arg.Quantity)
	var i CharacterInventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO character_inventories (
  character_id,
  item_id,
  quantity
)
VALUES ($1, $2, $3)
RETURNING id, character_id, item_id, quantity, created_at, updated_at
`

type CreateInventoryItemParams struct {
	CharacterID pgtype.UUID
	ItemID      int32
	Quantity    int32
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (CharacterInventory, error) {
	row := q.db.QueryRow(ctx, createInventoryItem, arg.CharacterID, arg.ItemID, arg.Quantity)
	var i CharacterInventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEmptyInventoryItems = `-- name: DeleteEmptyInventoryItems :exec
DELETE FROM character_inventories
WHERE character_id = $1 AND quantity <= 0
`

func (q *Queries) DeleteEmptyInventoryItems(ctx context.Context, characterID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEmptyInventoryItems, characterID)
	return err
}

const deleteInventoryItem = `-- name: DeleteInventoryItem :exec
DELETE FROM character_inventories
WHERE character_id = $1 AND item_id = $2
`

type DeleteInventoryItemParams struct {
	CharacterID pgtype.UUID
	ItemID      int32
}

func (q *Queries) DeleteInventoryItem(ctx context.Context, arg DeleteInventoryItemParams) error {
	_, err := q.db.Exec(ctx, deleteInventoryItem, arg.CharacterID, arg.ItemID)
	return err
}

const getCharacterInventory = `-- name: GetCharacterInventory :many

SELECT
  ci.id,
  ci.character_id,
  ci.item_id,
  ci.quantity,
  ci.created_at,
  ci.updated_at,
  i.name as item_name,
  i.description as item_description,
  i.item_type,
  i.rarity,
  i.stack_size,
  i.visual_data
FROM character_inventories ci
JOIN items i ON ci.item_id = i.id
WHERE ci.character_id = $1
ORDER BY i.name
`

type GetCharacterInventoryRow struct {
	ID              int32
	CharacterID     pgtype.UUID
	ItemID          int32
	Quantity        int32
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	ItemName        string
	ItemDescription string
	ItemType        string
	Rarity          string
	StackSize       int32
	VisualData      []byte
}

// Character inventory operations
func (q *Queries) GetCharacterInventory(ctx context.Context, characterID pgtype.UUID) ([]GetCharacterInventoryRow, error) {
	rows, err := q.db.Query(ctx, getCharacterInventory, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCharacterInventoryRow
	for rows.Next() {
		var i GetCharacterInventoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CharacterID,
			&i.ItemID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemName,
			&i.ItemDescription,
			&i.ItemType,
			&i.Rarity,
			&i.StackSize,
			&i.VisualData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItem = `-- name: GetInventoryItem :one
SELECT
  ci.id,
  ci.character_id,
  ci.item_id,
  ci.quantity,
  ci.created_at,
  ci.updated_at,
  i.name as item_name,
  i.description as item_description,
  i.item_type,
  i.rarity,
  i.stack_size,
  i.visual_data
FROM character_inventories ci
JOIN items i ON ci.item_id = i.id
WHERE ci.character_id = $1 AND ci.item_id = $2
`

type GetInventoryItemParams struct {
	CharacterID pgtype.UUID
	ItemID      int32
}

type GetInventoryItemRow struct {
	ID              int32
	CharacterID     pgtype.UUID
	ItemID          int32
	Quantity        int32
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	ItemName        string
	ItemDescription string
	ItemType        string
	Rarity          string
	StackSize       int32
	VisualData      []byte
}

func (q *Queries) GetInventoryItem(ctx context.Context, arg GetInventoryItemParams) (GetInventoryItemRow, error) {
	row := q.db.QueryRow(ctx, getInventoryItem, arg.CharacterID, arg.ItemID)
	var i GetInventoryItemRow
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ItemName,
		&i.ItemDescription,
		&i.ItemType,
		&i.Rarity,
		&i.StackSize,
		&i.VisualData,
	)
	return i, err
}

const getInventoryItemCount = `-- name: GetInventoryItemCount :one
SELECT COUNT(*) FROM character_inventories
WHERE character_id = $1
`

func (q *Queries) GetInventoryItemCount(ctx context.Context, characterID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getInventoryItemCount, characterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getInventoryItemTotalQuantity = `-- name: GetInventoryItemTotalQuantity :one
SELECT COALESCE(SUM(quantity), 0) FROM character_inventories
WHERE character_id = $1
`

func (q *Queries) GetInventoryItemTotalQuantity(ctx context.Context, characterID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getInventoryItemTotalQuantity, characterID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const inventoryItemExists = `-- name: InventoryItemExists :one
SELECT EXISTS(
  SELECT 1 FROM character_inventories
  WHERE character_id = $1 AND item_id = $2
)
`

type InventoryItemExistsParams struct {
	CharacterID pgtype.UUID
	ItemID      int32
}

func (q *Queries) InventoryItemExists(ctx context.Context, arg InventoryItemExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, inventoryItemExists, arg.CharacterID, arg.ItemID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeInventoryItemQuantity = `-- name: RemoveInventoryItemQuantity :one
UPDATE character_inventories
SET 
  quantity = quantity - $3,
  updated_at = NOW()
WHERE character_id = $1 AND item_id = $2 AND quantity >= $3
RETURNING id, character_id, item_id, quantity, created_at, updated_at
`

type RemoveInventoryItemQuantityParams struct {
	CharacterID pgtype.UUID
	ItemID      int32
	Quantity    int32
}

func (q *Queries) RemoveInventoryItemQuantity(ctx context.Context, arg RemoveInventoryItemQuantityParams) (CharacterInventory, error) {
	row := q.db.QueryRow(ctx, removeInventoryItemQuantity, arg.CharacterID, arg.ItemID, arg.Quantity)
	var i CharacterInventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInventoryItemQuantity = `-- name: UpdateInventoryItemQuantity :one
UPDATE character_inventories
SET 
  quantity = $3,
  updated_at = NOW()
WHERE character_id = $1 AND item_id = $2
RETURNING id, character_id, item_id, quantity, created_at, updated_at
`

type UpdateInventoryItemQuantityParams struct {
	CharacterID pgtype.UUID
	ItemID      int32
	Quantity    int32
}

func (q *Queries) UpdateInventoryItemQuantity(ctx context.Context, arg UpdateInventoryItemQuantityParams) (CharacterInventory, error) {
	row := q.db.QueryRow(ctx, updateInventoryItemQuantity, arg.CharacterID, arg.ItemID, arg.Quantity)
	var i CharacterInventory
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.ItemID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
