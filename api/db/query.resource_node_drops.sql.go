// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.resource_node_drops.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResourceNodeDrop = `-- name: CreateResourceNodeDrop :one
INSERT INTO resource_node_drops (
  resource_node_type_id,
  item_id,
  chance,
  min_quantity,
  max_quantity
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, resource_node_type_id, item_id, chance, min_quantity, max_quantity, created_at
`

type CreateResourceNodeDropParams struct {
	ResourceNodeTypeID int32
	ItemID             int32
	Chance             pgtype.Numeric
	MinQuantity        int32
	MaxQuantity        int32
}

func (q *Queries) CreateResourceNodeDrop(ctx context.Context, arg CreateResourceNodeDropParams) (ResourceNodeDrop, error) {
	row := q.db.QueryRow(ctx, createResourceNodeDrop,
		arg.ResourceNodeTypeID,
		arg.ItemID,
		arg.Chance,
		arg.MinQuantity,
		arg.MaxQuantity,
	)
	var i ResourceNodeDrop
	err := row.Scan(
		&i.ID,
		&i.ResourceNodeTypeID,
		&i.ItemID,
		&i.Chance,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllResourceNodeDrops = `-- name: DeleteAllResourceNodeDrops :exec
DELETE FROM resource_node_drops
WHERE resource_node_type_id = $1
`

func (q *Queries) DeleteAllResourceNodeDrops(ctx context.Context, resourceNodeTypeID int32) error {
	_, err := q.db.Exec(ctx, deleteAllResourceNodeDrops, resourceNodeTypeID)
	return err
}

const deleteResourceNodeDrop = `-- name: DeleteResourceNodeDrop :exec
DELETE FROM resource_node_drops
WHERE resource_node_type_id = $1 AND item_id = $2
`

type DeleteResourceNodeDropParams struct {
	ResourceNodeTypeID int32
	ItemID             int32
}

func (q *Queries) DeleteResourceNodeDrop(ctx context.Context, arg DeleteResourceNodeDropParams) error {
	_, err := q.db.Exec(ctx, deleteResourceNodeDrop, arg.ResourceNodeTypeID, arg.ItemID)
	return err
}

const getAllResourceNodeDrops = `-- name: GetAllResourceNodeDrops :many
SELECT
  rnd.id,
  rnd.resource_node_type_id,
  rnd.item_id,
  rnd.chance,
  rnd.min_quantity,
  rnd.max_quantity,
  rnd.created_at,
  i.name as item_name,
  i.description as item_description,
  i.item_type,
  i.rarity,
  i.stack_size,
  i.visual_data
FROM resource_node_drops rnd
JOIN items i ON rnd.item_id = i.id
ORDER BY rnd.resource_node_type_id, rnd.chance DESC
`

type GetAllResourceNodeDropsRow struct {
	ID                 int32
	ResourceNodeTypeID int32
	ItemID             int32
	Chance             pgtype.Numeric
	MinQuantity        int32
	MaxQuantity        int32
	CreatedAt          pgtype.Timestamp
	ItemName           string
	ItemDescription    string
	ItemType           string
	Rarity             string
	StackSize          int32
	VisualData         []byte
}

func (q *Queries) GetAllResourceNodeDrops(ctx context.Context) ([]GetAllResourceNodeDropsRow, error) {
	rows, err := q.db.Query(ctx, getAllResourceNodeDrops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllResourceNodeDropsRow
	for rows.Next() {
		var i GetAllResourceNodeDropsRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceNodeTypeID,
			&i.ItemID,
			&i.Chance,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.CreatedAt,
			&i.ItemName,
			&i.ItemDescription,
			&i.ItemType,
			&i.Rarity,
			&i.StackSize,
			&i.VisualData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResourceNodeDrops = `-- name: GetResourceNodeDrops :many

SELECT
  rnd.id,
  rnd.resource_node_type_id,
  rnd.item_id,
  rnd.chance,
  rnd.min_quantity,
  rnd.max_quantity,
  rnd.created_at,
  i.name as item_name,
  i.description as item_description,
  i.item_type,
  i.rarity,
  i.stack_size,
  i.visual_data
FROM resource_node_drops rnd
JOIN items i ON rnd.item_id = i.id
WHERE rnd.resource_node_type_id = $1
ORDER BY rnd.chance DESC
`

type GetResourceNodeDropsRow struct {
	ID                 int32
	ResourceNodeTypeID int32
	ItemID             int32
	Chance             pgtype.Numeric
	MinQuantity        int32
	MaxQuantity        int32
	CreatedAt          pgtype.Timestamp
	ItemName           string
	ItemDescription    string
	ItemType           string
	Rarity             string
	StackSize          int32
	VisualData         []byte
}

// Resource node drops operations
func (q *Queries) GetResourceNodeDrops(ctx context.Context, resourceNodeTypeID int32) ([]GetResourceNodeDropsRow, error) {
	rows, err := q.db.Query(ctx, getResourceNodeDrops, resourceNodeTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceNodeDropsRow
	for rows.Next() {
		var i GetResourceNodeDropsRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceNodeTypeID,
			&i.ItemID,
			&i.Chance,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.CreatedAt,
			&i.ItemName,
			&i.ItemDescription,
			&i.ItemType,
			&i.Rarity,
			&i.StackSize,
			&i.VisualData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResourceNodeDrop = `-- name: UpdateResourceNodeDrop :one
UPDATE resource_node_drops
SET
  chance = $3,
  min_quantity = $4,
  max_quantity = $5
WHERE resource_node_type_id = $1 AND item_id = $2
RETURNING id, resource_node_type_id, item_id, chance, min_quantity, max_quantity, created_at
`

type UpdateResourceNodeDropParams struct {
	ResourceNodeTypeID int32
	ItemID             int32
	Chance             pgtype.Numeric
	MinQuantity        int32
	MaxQuantity        int32
}

func (q *Queries) UpdateResourceNodeDrop(ctx context.Context, arg UpdateResourceNodeDropParams) (ResourceNodeDrop, error) {
	row := q.db.QueryRow(ctx, updateResourceNodeDrop,
		arg.ResourceNodeTypeID,
		arg.ItemID,
		arg.Chance,
		arg.MinQuantity,
		arg.MaxQuantity,
	)
	var i ResourceNodeDrop
	err := row.Scan(
		&i.ID,
		&i.ResourceNodeTypeID,
		&i.ItemID,
		&i.Chance,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.CreatedAt,
	)
	return i, err
}
